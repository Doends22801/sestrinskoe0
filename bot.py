import os
import logging
import random
import re
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes

# Настройка логирования
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Получение токена из переменных окружения
BOT_TOKEN = os.getenv('BOT_TOKEN')
if not BOT_TOKEN:
    logger.error("BOT_TOKEN не установлен!")
    exit(1)

# Медицинские вопросы (полностью обновленные)
TEST_DATA = [
    {
        'question': 'Общие принципы лечения вывихов',
        'options': [
            'Иммобилизация, санация, диета',
            'Вправление, репозиция, санаторно-курортное лечение',
            'Репозиция, иммобилизация, реабилитация',
            'Вправление, фиксация, реабилитация',
            'Операция, реабилитация, фиксация'
        ],
        'correct_answers': ['Вправление, фиксация, реабилитация']
    },
    {
        'question': 'При гипогликемическом состоянии необходимо',
        'options': [
            'Напоить больного сладким чаем',
            'Срочно ввести простой инсулин',
            'Дать щелочное питье'
        ],
        'correct_answers': ['Напоить больного сладким чаем']
    },
    {
        'question': 'Запах ацетона изо рта наблюдается у больного при коме',
        'options': [
            'Гипогликемической',
            'Гипергликемической',
            'Печеночной',
            'Уремической'
        ],
        'correct_answers': ['Гипергликемической']
    },
    {
        'question': 'Влажные кожные покровы характерны для комы',
        'options': [
            'Гипергликемической',
            'Гипогликемической',
            'Уремической',
            'Почечной'
        ],
        'correct_answers': ['Гипогликемической']
    },
    {
        'question': 'Заболевания, которые приводят к развитию гипергликемической комы',
        'options': [
            'Инфаркт миокарда',
            'Вирусный гепатит',
            'Мочекаменная болезнь',
            'Сахарный диабет',
            'Аспирационная пневмония'
        ],
        'correct_answers': ['Сахарный диабет']
    },
    {
        'question': 'Жировая эмболия наблюдается при',
        'options': [
            'Эфирных судорогах',
            'Тиреоидном кризе',
            'Переломах длинных трубчатых костей',
            'Переливании крови',
            'Гемотрансфузионном шоке'
        ],
        'correct_answers': ['Переломах длинных трубчатых костей']
    },
    {
        'question': 'При проникающем ранении глазного яблока накладывается',
        'options': [
            'Т-образная повязка',
            'Крестообразная повязка на оба глаза (бинокулярная)',
            'Praщевидная повязка'
        ],
        'correct_answers': ['Крестообразная повязка на оба глаза (бинокулярная)']
    },
    {
        'question': 'Инородное тело, воткнувшееся в глазное яблоко, удалять',
        'options': [
            'Можно',
            'Нельзя'
        ],
        'correct_answers': ['Нельзя']
    },
    {
        'question': 'При отравлении метиловым спиртом антидотом является',
        'options': [
            'Этиловый спирт 70%',
            'Атропин',
            'Унитиол',
            'Тиосульфат натрия'
        ],
        'correct_answers': ['Этиловый спирт 70%']
    },
    {
        'question': 'Гематома-это скопление крови',
        'options': [
            'В плевральной полости',
            'В полости сустава',
            'В брюшной полости',
            'Пропитывание тканей кровью',
            'Ограниченное тканями'
        ],
        'correct_answers': ['Ограниченное тканями']
    },
    {
        'question': 'При правильном наложения венозных жгутов пульс на периферических сосудах',
        'options': [
            'сохраняется',
            'исчезает'
        ],
        'correct_answers': ['исчезает']
    },
    {
        'question': 'Количество единиц антибиотика в 1 мл растворителя при разведении его для постановки внутрикожной пробы',
        'options': [
            '10 000 ЕД.',
            '100 000 ЕД.',
            '500 000 ЕД.',
            '1 000 000 ЕД.'
        ],
        'correct_answers': ['100 000 ЕД.']
    },
    {
        'question': 'Место постановки внутрикожной пробы',
        'options': [
            'Наружная поверхность бедра',
            'Верхний наружный квадрат ягодицы',
            'Под лопатку',
            'Средняя треть внутренней поверхности предплечья'
        ],
        'correct_answers': ['Средняя треть внутренней поверхности предплечья']
    },
    {
        'question': 'При взятии крови одновременно на несколько биохимических анализов необходимо исходить из расчета, что на один анализ берется',
        'options': [
            '1 мл крови',
            '2 мл крови',
            '3 мл крови',
            '4 мл крови'
        ],
        'correct_answers': ['2 мл крови']
    },
    {
        'question': 'Особое влияние стресс оказывает на показатели анализов',
        'options': [
            'Клинических',
            'Биохимических',
            'Бактериологических',
            'Серологических'
        ],
        'correct_answers': ['Биохимических']
    },
    {
        'question': 'Мокроту для бактериологического исследования необходимо собрать в',
        'options': [
            'Чистую банку',
            'Стерильную банку',
            'Карманную плевательницу',
            'Чистую пробирку'
        ],
        'correct_answers': ['Стерильную банку']
    },
    {
        'question': 'При учете суточного диуреза мочегонные средства отменяются за',
        'options': [
            '6 ч',
            '12 ч',
            '24 ч',
            '8 ч'
        ],
        'correct_answers': ['24 ч']
    },
    {
        'question': 'Целью сбора мочи по зимницкому является исследование функции почек',
        'options': [
            'Секреторной и выделительной',
            'Секреторной и экскреторной',
            'Концентрационной и выделительной'
        ],
        'correct_answers': ['Концентрационной и выделительной']
    },
    {
        'question': 'Суточный диурез измеряется для определения',
        'options': [
            'Концентрационной функции',
            'Патологических элементов в моче',
            'Выделительной функции'
        ],
        'correct_answers': ['Выделительной функции']
    },
    {
        'question': 'Для общего анализа мочи собирается',
        'options': [
            'Средняя порция мочи',
            'Вся выделенная моча',
            'Моча, выделенная за сутки',
            'Первая порция'
        ],
        'correct_answers': ['Средняя порция мочи']
    },
    {
        'question': 'При определении сахара в моче из суточного диуреза на этикетке необходимо указать',
        'options': [
            'Общее количество мочи, выделенное за сутки',
            'Количество мочи, доставленное в емкости',
            'Количество жидкости, потребляемой за сутки',
            'Количество съеденного сахара'
        ],
        'correct_answers': ['Общее количество мочи, выделенное за сутки']
    },
    {
        'question': 'Нормальное артериальное давление - это давление (мм рт.ст.)',
        'options': [
            'Меньше 120/80',
            'Меньше 130/85',
            'Больше 130/85',
            'Больше 140/90'
        ],
        'correct_answers': ['Меньше 130/85']
    },
    {
        'question': 'Плевральную пункцию проводят с целью',
        'options': [
            'Разъединения плевральных сращений',
            'Отсасывание мокроты из бронхов',
            'Уменьшение болевого синдрома',
            'Удаление жидкости из плевральной полости'
        ],
        'correct_answers': ['Удаление жидкости из плевральной полости']
    },
    {
        'question': 'Кратковременная потеря сознания - это',
        'options': [
            'Кома',
            'Коллапс',
            'Обморок',
            'Сопор'
        ],
        'correct_answers': ['Обморок']
    },
    {
        'question': 'Скопление жидкости в брюшной полости - это',
        'options': [
            'Анасарка',
            'Гидроторакс',
            'Асцит',
            'Гидроперикардит'
        ],
        'correct_answers': ['Асцит']
    },
    {
        'question': 'Медсестра может определить наличие отеков у пациента на ногах методом',
        'options': [
            'Взвешивания',
            'Пальпации',
            'Измерения суточного диуреза',
            'Аускультации',
            'Перкуссии'
        ],
        'correct_answers': ['Пальпации']
    },
    {
        'question': 'Если пациенту впервые назначен инсулин, медсестра объясняет пациенту, что он',
        'options': [
            'Снижает уровень холестерина в крови',
            'Способствует усвоению глюкозы крови клетками',
            'Стимулирует деятельность клеток поджелудочной железы',
            'Способствует выведению сахара из организма'
        ],
        'correct_answers': ['Способствует усвоению глюкозы крови клетками']
    },
    {
        'question': 'Характер боли во время приступа стенокардии',
        'options': [
            'Ноющая',
            'Тупая',
            'Колющая',
            'Сжимающая'
        ],
        'correct_answers': ['Сжимающая']
    },
    {
        'question': 'При стенокардии боль локализуется',
        'options': [
            'За грудиной, в области сердца',
            'В области сердца, в правом подреберье',
            'В правом подреберье, в поясничной области',
            'В поясничной области'
        ],
        'correct_answers': ['За грудиной, в области сердца']
    },
    {
        'question': 'Приступ стенокардии купируется',
        'options': [
            'Настойкой валерианы',
            'Димедролом',
            'Нитроглицерином',
            'Анаприлином'
        ],
        'correct_answers': ['Нитроглицерином']
    },
    {
        'question': 'Причины бронхитов',
        'options': [
            'Риккетсии и простейшие',
            'Простейшие и грибы',
            'Грибы и бактерии',
            'Бактерии и вирусы'
        ],
        'correct_answers': ['Бактерии и вирусы']
    },
    {
        'question': 'Аллергены, вызывающие приступы бронхиальной астмы',
        'options': [
            'Домашняя пыль',
            'Домашняя пыль и продукты пчеловодства',
            'Домашняя пыль, продукты пчеловодства и антибиотики',
            'Домашняя пыль, продукты пчеловодства, антибиотики и пыльца растений'
        ],
        'correct_answers': ['Домашняя пыль, продукты пчеловодства, антибиотики и пыльца растений']
    },
    {
        'question': 'При ирригоскопии исследуемый орган -',
        'options': [
            'Желудок',
            'Желчный пузырь',
            'Толстый кишечник',
            'Тонкий кишечник',
            'Пищевод'
        ],
        'correct_answers': ['Толстый кишечник']
    },
    {
        'question': 'Экг-это запись',
        'options': [
            'Функциональных шумов сердца',
            'Электрических колебаний, возникающих в сердце',
            'Ультразвуковых волн',
            'Тонов сердца'
        ],
        'correct_answers': ['Электрических колебаний, возникающих в сердце']
    },
    {
        'question': 'Лекарства в катетер, стоящий в центральной вене, вводят',
        'options': [
            'Через заглушку',
            'Заглушку отсоединяют'
        ],
        'correct_answers': ['Через заглушку']
    },
    {
        'question': 'Асептическая повязка вокруг катетера в центральной вене меняется не реже чем',
        'options': [
            '2 раза в сут',
            '1 раз в сут',
            'Через 2 сут',
            'Через 3 сут'
        ],
        'correct_answers': ['1 раз в сут']
    },
    {
        'question': 'При длительной инфузионной терапии для обеспечения и поддержания периферического венозного доступа применяется',
        'options': [
            'Венепункция',
            'Венесекция',
            'Катетеризация'
        ],
        'correct_answers': ['Катетеризация']
    },
    {
        'question': 'Подлокотник (клеенчатая подушка) при венозном доступе используется для',
        'options': [
            'Стабилизации руки в местах сгиба (суставах)',
            'Ограничения движения пациентов',
            'Удобства пациента'
        ],
        'correct_answers': ['Стабилизации руки в местах сгиба (суставах)']
    },
    {
        'question': 'Для обеспечения венозного наполнения конечности при венозном доступе используется',
        'options': [
            'Жгут',
            'Подлокотник',
            'Давящая повязка'
        ],
        'correct_answers': ['Жгут']
    },
    {
        'question': 'Повторное использование колпачков и заглушек на катетере',
        'options': [
            'Допускается',
            'Разрешается',
            'Запрещается'
        ],
        'correct_answers': ['Запрещается']
    },
    {
        'question': 'Возможные осложнения периферического венозного катетера (пвк)',
        'options': [
            'Флебит и тромбофлебит',
            'Инфильтрация и экстравазация',
            'Гематома, тромбоз, тромбофлебит',
            'Инфильтрация, экстравазация, гематома, тромбоз, флебит, тромбофлебит'
        ],
        'correct_answers': ['Инфильтрация, экстравазация, гематома, тромбоз, флебит, тромбофлебит']
    },
    {
        'question': 'Профилактические мероприятия в лпо проводятся исходя из положения, что каждый пациент расценивается как потенциальный источник',
        'options': [
            'Гемоконтактных инфекций (гепатит В, С, ВИЧ)',
            'Педикулеза',
            'Кишечных инфекций',
            'Туберкулеза',
            'Венерических болезней'
        ],
        'correct_answers': ['Гемоконтактных инфекций (гепатит В, С, ВИЧ)']
    },
    {
        'question': 'Все пациенты на догоспитальном этапе подлежат профилактическому обследованию на',
        'options': [
            'Туберкулез (флюорография)',
            'Маркеры гепатитов В и С, сифилис',
            'Дифтерию и кишечные инфекции',
            'Кишечные инфекции',
            'Стафилококк'
        ],
        'correct_answers': ['Туберкулез (флюорография)']
    },
    {
        'question': 'В случае оперативного лечения пациенты на догоспитальном этапе подлежат профилактическому обследованию на',
        'options': [
            'Туберкулез (флюорография)',
            'Маркеры гепатитов В и С, сифилис',
            'Дифтерию и кишечные инфекции',
            'Стафилококк',
            'Кишечные инфекции'
        ],
        'correct_answers': ['Маркеры гепатитов В и С, сифилис', 'Туберкулез (флюорография)']
    },
    {
        'question': 'Пациенты с инфекцией, вызванной резистентными золотистым стафилококком или энтерококком, изоляции в боксированные палаты',
        'options': [
            'Подлежат',
            'Не подлежат'
        ],
        'correct_answers': ['Подлежат']
    },
    {
        'question': 'Периодический инструктаж персонала, осуществляющего уборку, по санэпидрежиму и технике безопасности проводится не реже чем',
        'options': [
            'Ежемесячно',
            'Ежеквартально',
            '2 раза в год',
            '1 раз в год'
        ],
        'correct_answers': ['2 раза в год']
    },
    {
        'question': 'Как называется процесс обработки мед. отходов класс Б.В',
        'options': [
            'Утилизация',
            'Дезинфекция',
            'Обеззараживание',
            'Замачивание'
        ],
        'correct_answers': ['Дезинфекция']
    },
    {
        'question': 'Генеральная уборка помещений палатных отделений и кабинетов проводится по графику, но не реже',
        'options': [
            'раз в 3 дня',
            '1 раз в неделю',
            '1 раз в 10 дней',
            'раз в месяц',
            '1 раз в 20 дней'
        ],
        'correct_answers': ['раз в месяц']
    },
    {
        'question': 'Частота проведения генеральной уборки в помещениях с асептическим режимом',
        'options': [
            '1 раз в 3 дня',
            '1 раз в неделю',
            '1 раз в 10 дней',
            '1 раз в месяц',
            '1 раз в 20дней'
        ],
        'correct_answers': ['1 раз в неделю']
    },
    {
        'question': 'Генеральная уборка помещений палатных отделений должна проводиться с обработкой',
        'options': [
            'оконных стекол и стен',
            'стен, потолка, оконных стекол',
            'дверей, стен, оборудования, мебели и полов',
            'стен, полов, оборудования, инвентаря',
            'стен, полов, окон, дверей, мебели, оборудования, инвентаря, светильников'
        ],
        'correct_answers': ['стен, полов, окон, дверей, мебели, оборудования, инвентаря, светильников']
    },
    {
        'question': 'Обеззараживание воздуха уфо в присутствии людей можно проводить, используя только',
        'options': [
            'Открытые облучатели',
            'Закрытые облучатели',
            'Рециркуляторы'
        ],
        'correct_answers': ['Рециркуляторы']
    },
    {
        'question': 'В какой цветом собирают отходы класса Б',
        'options': [
            'Черный',
            'Желтый',
            'Красный',
            'Белый'
        ],
        'correct_answers': ['Желтый']
    },
    {
        'question': 'Сколько классов существует медицинских отходов в РФ',
        'options': [
            '6',
            '4',
            '5'
        ],
        'correct_answers': ['5']
    },
    {
        'question': 'Эпидемически опасные отходы относятся к классу:',
        'options': [
            'Б',
            'В'
        ],
        'correct_answers': ['Б']
    },
    {
        'question': 'Текущая уборка процедурного кабинета проводится не менее чем',
        'options': [
            '1 раз в день перед началом работы',
            '2 раза в день',
            '3 раза в сутки'
        ],
        'correct_answers': ['2 раза в день']
    },
    {
        'question': 'При увлажнении поверхностей помещения эффективность ультрафиолетового облучения',
        'options': [
            'Возрастает',
            'Не изменяется',
            'Снижается'
        ],
        'correct_answers': ['Снижается']
    },
    {
        'question': 'Предметы ухода, оборудование и все, что соприкасается с неповрежденной кожей, подлежат только',
        'options': [
            'Дезинфекции',
            'Предстерилизационной очистке',
            'Стерилизации'
        ],
        'correct_answers': ['Дезинфекции']
    },
    {
        'question': 'Метод дезинфекции манжетки для измерения давления',
        'options': [
            'Орошение дез раствором',
            'Протирание 70% спиртом'
        ],
        'correct_answers': ['Протирание 70% спиртом']
    },
    {
        'question': 'Метод дезинфекции термометра медицинского',
        'options': [
            'Протирание 70% спиртом',
            'Орошение дез. средством'
        ],
        'correct_answers': ['Орошение дез. средством']
    },
    {
        'question': 'Что Запрещено делать при обращении с медицинскими отходами:',
        'options': [
            'Ставить тару с мед. отходами на расстоянии 1,5 от отопительных приборов',
            'Снимать иглу с использованных шприцов',
            'Складывать острые инструменты в пакеты',
            'Собирать отходы без перчаток'
        ],
        'correct_answers': ['Снимать иглу с использованных шприцов', 'Складывать острые инструменты в пакеты', 'Собирать отходы без перчаток']
    },
    {
        'question': 'Правила обработки рук медицинского персонала и кожных покровов пациента лпо регламентируется',
        'options': [
            'СанПиН 2.1.3678-20',
            'ОСТ-42-21-2-85'
        ],
        'correct_answers': ['СанПиН 2.1.3678-20']
    },
    {
        'question': 'Цель гигиенического мытья рук медперсонала перед осмотром пациента',
        'options': [
            'Обеспечение кратковременной стерильности',
            'Создание продолжительной стерильности',
            'Профилактика профессионального заражения',
            'Удаление транзиторной микрофлоры'
        ],
        'correct_answers': ['Удаление транзиторной микрофлоры']
    },
    {
        'question': 'Цель гигиенической обработки рук медперсонала кожным антисептиком',
        'options': [
            'Снижение количества микроорганизмов',
            'Создание продолжительной стерильности',
            'Профилактика профессионального заражения',
            'Удаление бытового загрязнения'
        ],
        'correct_answers': ['Снижение количества микроорганизмов']
    },
    {
        'question': 'Цель дезинфекции рук медперсонала после инфекционного контакта',
        'options': [
            'Обеспечение кратковременной стерильности',
            'Создание продолжительной стерильности',
            'Профилактика профессионального заражения',
            'Удаление бытового загрязнения'
        ],
        'correct_answers': ['Профилактика профессионального заражения']
    },
    {
        'question': 'Стерильные перчатки надевают',
        'options': [
            'Сразу после обработки рук',
            'После полного высыхания антисептика на коже'
        ],
        'correct_answers': ['После полного высыхания антисептика на коже']
    },
    {
        'question': 'Вид обработки рук медперсонала перед накрыванием большого стерильного стола',
        'options': [
            'Хирургическая',
            'Гигиеническая с антисептиком',
            'Гигиеническое мытье с мылом и водой'
        ],
        'correct_answers': ['Хирургическая']
    },
    {
        'question': 'Стерильные перчатки надеваются только для выполнения процедур',
        'options': [
            'стерильных',
            'Нестерильных',
            'Любых'
        ],
        'correct_answers': ['стерильных']
    },
    {
        'question': 'Вид перчаток при заборе крови из вены на исследования',
        'options': [
            'Стерильные медицинские',
            'Чистые продезинфицированные'
        ],
        'correct_answers': ['Чистые продезинфицированные']
    },
    {
        'question': 'После каждого пациента перчатки',
        'options': [
            'Необходимо менять',
            'Протирать дезинфектантом, не меняя'
        ],
        'correct_answers': ['Необходимо менять']
    },
    {
        'question': 'Кожа инъекционного поля протирается стерильным ватным тампоном с кожным антисептиком',
        'options': [
            'Однократно',
            'Последовательно дважды',
            'Последовательно трижды в сут',
            'раз в сут',
            'Через 2 сут'
        ],
        'correct_answers': ['Однократно']
    },
    {
        'question': 'Место пункции вены обрабатывается стерильными марлевыми тампонами с кожным антисептиком',
        'options': [
            'Однократно',
            'Последовательно дважды',
            'Последовательно трижды'
        ],
        'correct_answers': ['Последовательно дважды']
    },
    {
        'question': 'Бактерицидные камеры, оснащенные ультрафиолетовыми лампами, допускаются к применению только',
        'options': [
            'для хранения стерильных инструментов',
            'для стерилизации',
            'Для дезинфекции'
        ],
        'correct_answers': ['для хранения стерильных инструментов']
    },
    {
        'question': 'Самым распространненым резервуаром возбудителей на теле человека являются',
        'options': [
            'Мочевыводящие пути',
            'руки',
            'кровь',
            'кишечник'
        ],
        'correct_answers': ['руки']
    },
    {
        'question': 'Стерильный пинцет в процессе работы со стерильным материалом должен храниться',
        'options': [
            'В сухом виде в стерильной упаковке',
            'В спиртовом растворе'
        ],
        'correct_answers': ['В сухом виде в стерильной упаковке']
    },
    {
        'question': 'Требования к правилам личной гигиены пациентов в лпо регламентируются',
        'options': [
            'СанПиН 3.3686-21',
            'Инструкциями ЛПО',
            'Санитарным минимумом',
            'Правилами внутреннего распорядка'
        ],
        'correct_answers': ['СанПиН 3.3686-21']
    },
    {
        'question': 'При использовании одноразовых контейнеров для острого инструментария допускается их заполнение в течении:',
        'options': [
            '72 часа',
            '24 часа'
        ],
        'correct_answers': ['72 часа']
    },
    {
        'question': 'Герметизация одноразовых пакетов для сбора отходов класс Б в местах их образования осуществляется после заполнения пакета на :',
        'options': [
            '1/3',
            '1/2',
            '3/4',
            '2/3'
        ],
        'correct_answers': ['3/4']
    },
    {
        'question': 'К работе с мед. отходами допускаются лица',
        'options': [
            'старше 20 лет',
            'старше 16 лет',
            'Старше 18 лет',
            'Неограниченный возраст'
        ],
        'correct_answers': ['Старше 18 лет']
    },
    {
        'question': 'Количество сердечных сокращений в одну минуту у взрослого в норме:',
        'options': [
            '100-120',
            '90-100',
            '60-80',
            '40-60'
        ],
        'correct_answers': ['60-80']
    },
    {
        'question': 'По наполнению пульс различают',
        'options': [
            'Ритмичный, аритмичный',
            'Скорый, медленный',
            'Полный, нитевидный',
            'Твердый, мягкий'
        ],
        'correct_answers': ['Полный, нитевидный']
    },
    {
        'question': 'Время подсчета пульса при аритмии (в секундах)',
        'options': [
            '60',
            '45',
            '30',
            '15'
        ],
        'correct_answers': ['60']
    },
    {
        'question': 'В норме частота пульса у взрослого человека',
        'options': [
            '60-80 уд/мин',
            '80-90 уд/мин',
            '60-70 уд/мин',
            '70-90 уд/мин'
        ],
        'correct_answers': ['60-80 уд/мин']
    },
    {
        'question': 'Медсестра рекомендует пациенту использовать карманный ингалятор при',
        'options': [
            'Кровохаркании',
            'Удушье',
            'Сухом упорном кашле',
            'Болях в грудной клетке'
        ],
        'correct_answers': ['Удушье']
    },
    {
        'question': 'Бронхоэктатическая болезнь - это',
        'options': [
            'Острое гнойное заболевание легких',
            'Хроническое гнойное заболевание легких',
            'Аллергическое заболевание'
        ],
        'correct_answers': ['Хроническое гнойное заболевание легких']
    },
    {
        'question': 'Для легочного кровотечения характерно',
        'options': [
            'Рвотные массы цвета «кофейной гущи»',
            'Алая пенистая кровь при кашле',
            'Темные сгустки крови в большом количестве',
            'Прожилки крови в мокроте'
        ],
        'correct_answers': ['Алая пенистая кровь при кашле']
    },
    {
        'question': 'Если у пациента появилось кровохарканье, то медсестра должна применить',
        'options': [
            'Щелочную ингаляцию',
            'Отвлекающую терапию',
            'Пузырь со льдом',
            'Дренажное положение'
        ],
        'correct_answers': ['Пузырь со льдом']
    },
    {
        'question': 'Клинические проявления анафилактического шока',
        'options': [
            'Нарушение сознания',
            'Нарушение сознания, одышка',
            'Нарушение сознания, одышка, снижение АД',
            'Нарушение сознания, одышка, снижение АД, боли в животе'
        ],
        'correct_answers': ['Нарушение сознания, одышка, снижение АД']
    },
    {
        'question': 'Клинические проявления крапивницы',
        'options': [
            'Кожный зуд',
            'Отек век',
            'Сыпь на коже',
            'Удушье'
        ],
        'correct_answers': ['Сыпь на коже', 'Кожный зуд']
    },
    {
        'question': 'Симптомы отека Квинке',
        'options': [
            'Боль за грудиной',
            'Кожный зуд',
            'Отек губ, век, носа',
            'Падение артериального давления'
        ],
        'correct_answers': ['Отек губ, век, носа']
    },
    {
        'question': 'Полное уничтожение микроорганизмов и их спор на инструментарии и белье достигается при',
        'options': [
            'дезинфекции',
            'педстерилизационной обработке',
            'стерилизации'
        ],
        'correct_answers': ['стерилизации']
    },
    {
        'question': 'При желудочном кровотечении характерен кал',
        'options': [
            'Жирный, мажущийся, глинистый',
            'Черный, дегтеобразный',
            'Светлый желтый',
            'В виде рисового отвара'
        ],
        'correct_answers': ['Черный, дегтеобразный']
    },
    {
        'question': 'Медсестра заподозрила желудочное кровотечение по следующему высказыванию пациента',
        'options': [
            '«Осенью я очень похудел»',
            '«Сегодня утром у меня был обильный стул черного цвета»',
            '«Последние две недели боли в животе усилились»'
        ],
        'correct_answers': ['«Сегодня утром у меня был обильный стул черного цвета»']
    },
    {
        'question': 'Парапроктит-это',
        'options': [
            'Доброкачественная опухоль прямой кишки',
            'Острое гнойное воспаление жировой клетчатки около прямой кишки',
            'Разрастание соединительной ткани',
            'Воспаление слизистой прямой кишки'
        ],
        'correct_answers': ['Острое гнойное воспаление жировой клетчатки около прямой кишки']
    },
    {
        'question': 'Бинтование начинают',
        'options': [
            'Непосредственно от раны, каждый тур бинта накладывается на предыдущий',
            'От центра к периферии, каждый тур бинта должен перекрывать предыдущий',
            'От периферии к центру, каждый оборот бинта должен перекрывать предыдущий наполовину или на две трети'
        ],
        'correct_answers': ['От периферии к центру, каждый оборот бинта должен перекрывать предыдущий наполовину или на две трети']
    },
    {
        'question': 'Пострадавшему с ранением головы как первая медицинская помощь накладывается повязка',
        'options': [
            'Уздечка',
            'Чепец',
            'Косыночная',
            'Дезо'
        ],
        'correct_answers': ['Чепец']
    },
    {
        'question': 'Название повязки на области коленного сустава',
        'options': [
            'Спиральная',
            'Черепашья',
            'Циркулярная',
            'Ползучая'
        ],
        'correct_answers': ['Черепашья']
    },
    {
        'question': 'При переломе нижней челюсти следует наложить',
        'options': [
            'Чепец',
            'Уздечку',
            'Praщевидную',
            'Крестообразную'
        ],
        'correct_answers': ['Praщевидную']
    },
    {
        'question': 'Типовая повязка - это повязка, которая накладывается',
        'options': [
            'В местах, типичных для различных травм и заболевании',
            'Из стандартных перевязочных материалов',
            'В различных областях тела одинаковыми турами бинта'
        ],
        'correct_answers': ['Из стандартных перевязочных материалов']
    },
    {
        'question': 'Этиловый спирт антимикробным, дубящим и обезжиривающим действием',
        'options': [
            'Обладает',
            'Нет, не обладает'
        ],
        'correct_answers': ['Обладает']
    },
    {
        'question': 'Дренирование гнойной раны тампоном с гипертоническим раствором - это вид антисептики',
        'options': [
            'Химический',
            'Биологический',
            'Физический'
        ],
        'correct_answers': ['Физический']
    }
]

# Хранение данных пользователей
user_data = {}


class UserProgress:
    def __init__(self):
        self.current_question_index = 0
        self.score = 0
        self.mistakes = []
        self.shuffled_questions = []
        self.pending_questions = []
        self.answered_correctly = set()
        self.current_attempts = 0
        self.mistakes_practice_mode = False
        self.mistakes_to_practice = []
        self.selected_answers = []
        self.current_question_data = None
        self.current_shuffled_options = []
        self.option_to_index_map = {}  # Маппинг текста ответа на индекс

    def initialize_test(self):
        """Инициализирует тест с нуля"""
        logger.info("Инициализация нового теста")
        self.shuffled_questions = TEST_DATA.copy()
        random.shuffle(self.shuffled_questions)
        self.pending_questions = self.shuffled_questions.copy()
        self.answered_correctly.clear()
        self.current_question_index = 0
        self.score = 0
        self.mistakes.clear()
        self.current_attempts = 0
        self.mistakes_practice_mode = False
        self.mistakes_to_practice.clear()
        self.selected_answers.clear()
        self.current_question_data = None
        self.current_shuffled_options.clear()
        self.option_to_index_map.clear()
        logger.info(f"Тест инициализирован с {len(self.shuffled_questions)} вопросами")

    def shuffle_options(self, question_data):
        """Перемешивает варианты ответов для вопроса"""
        options = question_data['options'].copy()
        random.shuffle(options)
        return options

    def get_current_question(self):
        """Получает текущий вопрос"""
        if self.mistakes_practice_mode:
            if not self.mistakes_to_practice:
                return None
            if self.current_question_index >= len(self.mistakes_to_practice):
                self.current_question_index = 0
                random.shuffle(self.mistakes_to_practice)
            return self.mistakes_to_practice[self.current_question_index]
        else:
            if not self.pending_questions:
                return None
            if self.current_question_index >= len(self.pending_questions):
                self.current_question_index = 0
                random.shuffle(self.pending_questions)
            return self.pending_questions[self.current_question_index]

    def is_answer_correct(self, selected_options, question_data):
        """Проверяет правильность ответа"""
        correct_answers = set(question_data['correct_answers'])
        selected_answers = set(selected_options)
        return selected_answers == correct_answers

    def handle_correct_answer(self, question_data):
        """Обрабатывает правильный ответ"""
        question_text = question_data['question']
        self.answered_correctly.add(question_text)

        if self.mistakes_practice_mode:
            self.mistakes_to_practice = [q for q in self.mistakes_to_practice if q['question'] != question_text]
            self.mistakes = [m for m in self.mistakes if m['question'] != question_text]
        else:
            self.pending_questions = [q for q in self.pending_questions if q['question'] != question_text]

        self.score += 1
        self.current_attempts = 0
        self.selected_answers.clear()

        if not self.mistakes_practice_mode:
            self.current_question_index += 1

    def handle_incorrect_answer(self, question_data, user_answers):
        """Обрабатывает неправильный ответ"""
        question_text = question_data['question']

        if not self.mistakes_practice_mode:
            if not any(m['question'] == question_text for m in self.mistakes):
                mistake_info = {
                    'question': question_text,
                    'user_answer': ", ".join(user_answers),
                    'correct_answer': ", ".join(question_data['correct_answers']),
                }
                self.mistakes.append(mistake_info)

        self.current_attempts += 1
        self.selected_answers.clear()

        if not self.mistakes_practice_mode:
            self.current_question_index += 1

    def is_test_complete(self):
        """Проверяет завершение теста"""
        if self.mistakes_practice_mode:
            return len(self.mistakes_to_practice) == 0
        else:
            return len(self.pending_questions) == 0

    def get_progress_text(self):
        """Возвращает текст прогресса"""
        if self.mistakes_practice_mode:
            total_mistakes = len(self.mistakes) + len(self.mistakes_to_practice)
            remaining = len(self.mistakes_to_practice)
            return f"Отработка ошибок: {total_mistakes - remaining}/{total_mistakes}"
        else:
            total_questions = len(self.shuffled_questions)
            answered = len(self.answered_correctly)
            remaining = len(self.pending_questions)
            return f"Прогресс: {answered}/{total_questions} | Осталось: {remaining}"

    def start_mistakes_practice(self):
        """Начинает режим отработки ошибок"""
        if not self.mistakes:
            logger.warning("Попытка начать отработку ошибок при их отсутствии")
            return False

        self.mistakes_practice_mode = True
        self.mistakes_to_practice.clear()

        for mistake in self.mistakes:
            for original_question in TEST_DATA:
                if original_question['question'] == mistake['question']:
                    self.mistakes_to_practice.append(original_question.copy())
                    break

        if not self.mistakes_to_practice:
            logger.error("Не удалось найти вопросы для отработки ошибок")
            return False

        random.shuffle(self.mistakes_to_practice)
        self.current_question_index = 0
        self.score = 0
        self.current_attempts = 0
        self.selected_answers.clear()
        logger.info(f"Начата отработка {len(self.mistakes_to_practice)} ошибок")
        return True

    def toggle_answer_selection(self, answer_text):
        """Добавляет или удаляет ответ из выбранных"""
        if answer_text in self.selected_answers:
            self.selected_answers.remove(answer_text)
        else:
            self.selected_answers.append(answer_text)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик команды /start"""
    logger.info(f"Пользователь {update.effective_user.id} запустил бота")
    welcome_text = """
🏥 Медицинский тест-бот

Доступные команды:
/start_test - Начать тестирование
/my_mistakes - Показать и отработать ошибки

🔄 В режиме отработки ошибок вопросы повторяются до правильного ответа!
⚡ Поддерживаются вопросы с несколькими правильными ответами!
    """
    await update.message.reply_text(welcome_text)


async def start_test(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Начало тестирования"""
    user_id = update.effective_user.id
    logger.info(f"Пользователь {user_id} начал тест")

    user_data[user_id] = UserProgress()
    user_data[user_id].initialize_test()
    await send_question(update, context, user_id)


async def send_question(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id: int):
    """Отправка вопроса пользователю"""
    logger.info(f"Отправка вопроса пользователю {user_id}")

    progress = user_data.get(user_id)
    if not progress:
        logger.error(f"Прогресс не найден для пользователя {user_id}")
        await handle_user_not_found(update)
        return

    if progress.is_test_complete():
        logger.info(f"Тест завершен для пользователя {user_id}")
        await finish_test(update, context, user_id)
        return

    question_data = progress.get_current_question()
    if not question_data:
        logger.error(f"Вопрос не найден для пользователя {user_id}")
        await finish_test(update, context, user_id)
        return

    # Подготавливаем данные вопроса
    shuffled_options = progress.shuffle_options(question_data)
    progress.current_question_data = question_data
    progress.current_shuffled_options = shuffled_options
    progress.option_to_index_map.clear()

    # Создаем маппинг текста ответа на индекс
    for idx, option in enumerate(shuffled_options):
        progress.option_to_index_map[option] = idx

    # Создаем клавиатуру
    keyboard = create_question_keyboard(progress, shuffled_options)
    reply_markup = InlineKeyboardMarkup(keyboard)

    # Формируем текст вопроса
    question_text = format_question_text(progress, question_data)

    # Отправляем сообщение
    try:
        if update.callback_query:
            await update.callback_query.edit_message_text(question_text, reply_markup=reply_markup)
        else:
            await update.message.reply_text(question_text, reply_markup=reply_markup)
        logger.info(f"Вопрос отправлен пользователю {user_id}")
    except Exception as e:
        logger.error(f"Ошибка отправки вопроса пользователю {user_id}: {e}")
        await handle_error(update, "Произошла ошибка при отправке вопроса")


def create_question_keyboard(progress, shuffled_options):
    """Создает клавиатуру для вопроса"""
    keyboard = []

    # Кнопки вариантов ответов
    for option in shuffled_options:
        prefix = "✅ " if option in progress.selected_answers else ""
        # Используем индекс варианта ответа как callback_data
        index = progress.option_to_index_map[option]
        keyboard.append([InlineKeyboardButton(f"{prefix}{option}", callback_data=f"select_{index}")])

    # Кнопка отправки ответа
    if progress.selected_answers:
        keyboard.append([InlineKeyboardButton("🚀 Отправить ответ", callback_data="submit_answers")])

    # Кнопка завершения теста (только в основном режиме)
    if not progress.mistakes_practice_mode:
        keyboard.append([InlineKeyboardButton("🚪 Завершить тестирование", callback_data="end_test")])

    return keyboard


def format_question_text(progress, question_data):
    """Форматирует текст вопроса"""
    progress_text = progress.get_progress_text()
    attempts_text = f" (Попытка: {progress.current_attempts + 1})" if progress.current_attempts > 0 else ""

    correct_count = len(question_data['correct_answers'])
    correct_info = f"\n📌 Правильных ответов: {correct_count}" if correct_count > 1 else ""

    if progress.mistakes_practice_mode:
        question_text = f"📝 {progress_text}{attempts_text}{correct_info}\nВопрос: {question_data['question']}"
    else:
        question_text = f"{progress_text}{attempts_text}{correct_info}\nВопрос: {question_data['question']}"

    # Показываем выбранные ответы
    if progress.selected_answers:
        selected_text = "\n\n✅ Выбрано: " + ", ".join(progress.selected_answers)
        question_text += selected_text

    return question_text


async def handle_user_not_found(update):
    """Обрабатывает случай, когда пользователь не найден"""
    text = "Тест не начат. Используйте /start_test"
    if update.callback_query:
        await update.callback_query.edit_message_text(text)
    else:
        await update.message.reply_text(text)


async def handle_error(update, message):
    """Обрабатывает ошибки"""
    if update.callback_query:
        await update.callback_query.edit_message_text(message)
    else:
        await update.message.reply_text(message)


async def handle_answer_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик выбора ответов"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    logger.info(f"Пользователь {user_id} выбрал ответ: {query.data}")

    progress = user_data.get(user_id)

    if not progress:
        logger.error(f"Прогресс не найден для пользователя {user_id} при выборе ответа")
        await query.edit_message_text("Тест не начат. Используйте /start_test")
        return

    if not progress.current_shuffled_options:
        logger.error(f"Варианты ответов не найдены для пользователя {user_id}")
        await query.answer("Ошибка: варианты ответов не загружены", show_alert=True)
        return

    try:
        index = int(query.data.replace("select_", ""))
        if index < 0 or index >= len(progress.current_shuffled_options):
            logger.error(f"Неверный индекс ответа {index} для пользователя {user_id}")
            await query.answer("Ошибка: неверный вариант ответа", show_alert=True)
            return

        original_text = progress.current_shuffled_options[index]
        progress.toggle_answer_selection(original_text)
        await send_question(update, context, user_id)
    except (ValueError, IndexError) as e:
        logger.error(f"Ошибка обработки выбора ответа для пользователя {user_id}: {e}")
        await query.answer("Ошибка: не удалось обработать выбор", show_alert=True)


async def handle_answer_submission(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик отправки ответов"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    logger.info(f"Пользователь {user_id} отправил ответ")

    progress = user_data.get(user_id)

    if not progress:
        logger.error(f"Прогресс не найден для пользователя {user_id} при отправке ответа")
        await query.edit_message_text("Тест не начат. Используйте /start_test")
        return

    if not progress.current_question_data:
        logger.error(f"Вопрос не найден для пользователя {user_id} при отправке ответа")
        await query.edit_message_text("Ошибка: вопрос не найден")
        return

    if not progress.selected_answers:
        await query.answer("Сначала выберите хотя бы один ответ!", show_alert=True)
        return

    question_data = progress.current_question_data
    is_correct = progress.is_answer_correct(progress.selected_answers, question_data)

    user_answers_text = ", ".join(progress.selected_answers)
    correct_answers_text = ", ".join(question_data['correct_answers'])

    logger.info(f"Ответ пользователя {user_id}: {user_answers_text}, правильный: {is_correct}")

    if is_correct:
        progress.handle_correct_answer(question_data)
        result_text = f"✅ Правильно!\n{progress.get_progress_text()}"
    else:
        progress.handle_incorrect_answer(question_data, progress.selected_answers)
        result_text = f"❌ Неправильно!\nВаш ответ: {user_answers_text}\nПравильный ответ: {correct_answers_text}\n{progress.get_progress_text()}"

    # Создаем кнопки для продолжения
    keyboard = []
    if not progress.is_test_complete():
        keyboard.append([InlineKeyboardButton("Следующий вопрос →", callback_data="next_question")])
    else:
        if progress.mistakes_practice_mode:
            keyboard.append([InlineKeyboardButton("🏁 Завершить отработку", callback_data="finish_mistakes_practice")])
        else:
            keyboard.append([InlineKeyboardButton("🏁 Завершить тест", callback_data="finish_test_now")])

    reply_markup = InlineKeyboardMarkup(keyboard)

    try:
        await query.edit_message_text(
            f"{result_text}\n\nНажмите для продолжения:",
            reply_markup=reply_markup
        )
    except Exception as e:
        logger.error(f"Ошибка отправки результата пользователю {user_id}: {e}")


async def next_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Переход к следующему вопросу"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    logger.info(f"Пользователь {user_id} переходит к следующему вопросу")

    progress = user_data.get(user_id)

    if not progress:
        logger.error(f"Прогресс не найден для пользователя {user_id} при переходе к следующему вопросу")
        await query.edit_message_text("Тест не начат. Используйте /start_test")
        return

    # В режиме отработки увеличиваем индекс при переходе
    if progress.mistakes_practice_mode and not progress.is_test_complete():
        progress.current_question_index += 1

    await send_question(update, context, user_id)


async def handle_end_test(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик досрочного завершения теста"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    logger.info(f"Пользователь {user_id} запросил завершение теста")

    progress = user_data.get(user_id)

    if not progress:
        logger.error(f"Прогресс не найден для пользователя {user_id} при запросе завершения теста")
        await query.edit_message_text("Тест не начат. Используйте /start_test")
        return

    keyboard = [
        [InlineKeyboardButton("✅ Да, завершить", callback_data="confirm_end_test")],
        [InlineKeyboardButton("❌ Нет, продолжить", callback_data="continue_test")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        f"Вы уверены, что хотите завершить тестирование?\n{progress.get_progress_text()}",
        reply_markup=reply_markup
    )


async def confirm_end_test(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Подтверждение досрочного завершения теста"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    logger.info(f"Пользователь {user_id} подтвердил завершение теста")

    await finish_test(update, context, user_id, early_exit=True)


async def continue_test(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Продолжение теста после отмены выхода"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    logger.info(f"Пользователь {user_id} продолжил тест")

    await send_question(update, context, user_id)


async def finish_test_now(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Завершение теста после последнего вопроса"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    logger.info(f"Пользователь {user_id} завершил тест")

    await finish_test(update, context, user_id)


async def finish_mistakes_practice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Завершение отработки ошибок"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    progress = user_data.get(user_id)

    if not progress:
        logger.error(f"Прогресс не найден для пользователя {user_id} при завершении отработки ошибок")
        await query.edit_message_text("Сессия не найдена")
        return

    if progress.mistakes:
        result_text = f"📊 Отработка завершена!\nОсталось ошибок: {len(progress.mistakes)}"
    else:
        result_text = "🎉 Поздравляем! Вы исправили все ошибки! 🏆"

    keyboard = [
        [InlineKeyboardButton("📝 Посмотреть ошибки", callback_data="view_mistakes")],
        [InlineKeyboardButton("🔄 Новый тест", callback_data="restart_test")],
        [InlineKeyboardButton("🚪 Завершить", callback_data="end_mistakes_session")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(result_text, reply_markup=reply_markup)


async def finish_test(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id: int, early_exit=False):
    """Завершение теста и вывод результатов"""
    progress = user_data.get(user_id)
    if not progress:
        logger.error(f"Прогресс не найден для пользователя {user_id} при завершении теста")
        await handle_user_not_found(update)
        return

    total_questions = len(progress.shuffled_questions)

    if early_exit:
        answered = len(progress.answered_correctly)
        result_text = (
            f"📊 Тест завершен досрочно!\n"
            f"Правильно отвечено: {answered}/{total_questions}\n"
            f"Осталось вопросов: {len(progress.pending_questions)}\n\n"
        )
    else:
        result_text = (
            f"🎉 Тест завершен!\n"
            f"Ваш результат: {progress.score}/{total_questions}\n"
            f"Процент правильных: {progress.score / total_questions * 100:.1f}%\n\n"
        )

    if progress.mistakes:
        result_text += f"Ошибок: {len(progress.mistakes)}\n"
        result_text += "Используйте /my_mistakes для отработки ошибок"
    else:
        result_text += "Поздравляем! Все ответы правильные! 🏆"

    keyboard = []
    if progress.mistakes:
        keyboard.append([InlineKeyboardButton("📝 Отработать ошибки", callback_data="practice_mistakes")])
    keyboard.append([InlineKeyboardButton("🔄 Новый тест", callback_data="restart_test")])

    reply_markup = InlineKeyboardMarkup(keyboard)

    try:
        if update.callback_query:
            await update.callback_query.edit_message_text(result_text, reply_markup=reply_markup)
        else:
            await update.message.reply_text(result_text, reply_markup=reply_markup)
    except Exception as e:
        logger.error(f"Ошибка завершения теста для пользователя {user_id}: {e}")


async def show_mistakes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Показать ошибки пользователя"""
    user_id = update.effective_user.id
    logger.info(f"Пользователь {user_id} запросил просмотр ошибок")

    progress = user_data.get(user_id)

    if not progress:
        await update.message.reply_text("Вы еще не проходили тестирование. Используйте /start_test")
        return

    if not progress.mistakes:
        await update.message.reply_text("🎉 У вас нет ошибок! Отличный результат!")
        return

    mistakes_text = "📋 Ваши ошибки:\n\n"
    for i, mistake in enumerate(progress.mistakes, 1):
        mistakes_text += (
            f"{i}. Вопрос: {mistake['question']}\n"
            f" Ваш ответ: ❌ {mistake['user_answer']}\n"
            f" Правильный: ✅ {mistake['correct_answer']}\n\n"
        )

    keyboard = [
        [InlineKeyboardButton("📝 Отработать ошибки", callback_data="practice_mistakes")],
        [InlineKeyboardButton("🚪 Завершить", callback_data="end_mistakes_session")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(mistakes_text, reply_markup=reply_markup)


async def handle_mistakes_actions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик действий с ошибками"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    logger.info(f"Пользователь {user_id} выполнил действие с ошибками: {query.data}")

    progress = user_data.get(user_id)

    if not progress:
        await query.edit_message_text("Сессия не найдена")
        return

    if query.data == "view_mistakes":
        if not progress.mistakes:
            await query.edit_message_text("У вас нет ошибок!")
            return

        mistakes_text = "📋 Ваши ошибки:\n\n"
        for i, mistake in enumerate(progress.mistakes, 1):
            mistakes_text += (
                f"{i}. {mistake['question']}\n"
                f" Ваш ответ: ❌ {mistake['user_answer']}\n"
                f" Правильный: ✅ {mistake['correct_answer']}\n\n"
            )

        keyboard = [
            [InlineKeyboardButton("📝 Отработать ошибки", callback_data="practice_mistakes")],
            [InlineKeyboardButton("🚪 Завершить", callback_data="end_mistakes_session")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(mistakes_text, reply_markup=reply_markup)

    elif query.data == "restart_test":
        user_data[user_id] = UserProgress()
        user_data[user_id].initialize_test()
        await send_question(update, context, user_id)

    elif query.data == "practice_mistakes":
        if progress.mistakes:
            if progress.start_mistakes_practice():
                await send_question(update, context, user_id)
            else:
                await query.edit_message_text("Не удалось начать отработку ошибок.")
        else:
            await query.edit_message_text("У вас нет ошибок для отработки!")

    elif query.data == "end_mistakes_session":
        await query.edit_message_text("Работа с ошибками завершена. Используйте /start_test для нового теста.")

    elif query.data == "finish_mistakes_practice":
        await finish_mistakes_practice(update, context)


def main():
    """Основная функция запуска бота"""
    logger.info("Запуск бота...")

    if not BOT_TOKEN or BOT_TOKEN == 'YOUR_BOT_TOKEN':
        logger.error("Токен бота не установлен! Замените YOUR_BOT_TOKEN на реальный токен.")
        return

    try:
        application = Application.builder().token(BOT_TOKEN).build()

        # Регистрация обработчиков команд
        application.add_handler(CommandHandler("start", start))
        application.add_handler(CommandHandler("start_test", start_test))
        application.add_handler(CommandHandler("my_mistakes", show_mistakes))

        # Регистрация обработчиков callback'ов
        application.add_handler(CallbackQueryHandler(handle_answer_selection, pattern="^select_"))
        application.add_handler(CallbackQueryHandler(handle_answer_submission, pattern="^submit_answers$"))
        application.add_handler(CallbackQueryHandler(next_question, pattern="^next_question$"))
        application.add_handler(CallbackQueryHandler(finish_test_now, pattern="^finish_test_now$"))
        application.add_handler(CallbackQueryHandler(finish_mistakes_practice, pattern="^finish_mistakes_practice$"))
        application.add_handler(CallbackQueryHandler(handle_end_test, pattern="^end_test$"))
        application.add_handler(CallbackQueryHandler(confirm_end_test, pattern="^confirm_end_test$"))
        application.add_handler(CallbackQueryHandler(continue_test, pattern="^continue_test$"))
        application.add_handler(CallbackQueryHandler(handle_mistakes_actions,
                                                     pattern="^(view_mistakes|restart_test|practice_mistakes|end_mistakes_session)$"))

        # Запуск бота
        logger.info("Бот успешно запущен и ожидает сообщений...")
        application.run_polling()

    except Exception as e:
        logger.error(f"Критическая ошибка при запуске бота: {e}")
    finally:
        logger.info("Бот остановлен")


if __name__ == '__main__':
    main()